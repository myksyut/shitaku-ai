# ADR-0002: 辞書機能のエージェント紐付け

## ステータス

**Proposed**

## 経緯

現在のユビキタス言語辞書はuser_id単位で管理されており、ユーザーが登録した全ての辞書エントリが全てのMTGエージェントで共有される。しかし、実際のビジネスシーンでは定例MTGごとに参加者や用語が異なり、不要な辞書エントリがアジェンダ生成のコンテキストを汚染する。

### 現在の課題

1. **コンテキスト汚染**: MTG Aの固有名詞がMTG Bのアジェンダ生成に影響を与える
2. **管理の困難さ**: 辞書エントリが増えるとどのMTGで使われているか把握困難
3. **LLM精度低下**: 無関係な辞書エントリがプロンプトに含まれ、アジェンダ生成の質が低下

### 変更の契機

- **MVP検証フェーズ**: 5〜10人のPM/EMによるフィードバックで辞書のスコープが問題となる可能性
- **アジェンダ生成精度**: 辞書をエージェントごとに分離することでLLMへの入力を最適化
- **PRD要件**: ユビキタス言語辞書はエージェント（MTGシリーズ）単位での管理が本質的な要件

## 決定事項

**辞書機能をuser_id紐付けからagent_id紐付けに変更する。**

### 決定の詳細

| 項目 | 内容 |
|-----|-----|
| **決定** | 辞書エントリをagent_id単位で管理する |
| **なぜ今か** | MVP検証前に正しいデータモデルを確立し、技術的負債を回避 |
| **なぜこれか** | エージェント単位の辞書管理はドメイン的に正しく、LLM精度向上に直結 |
| **既知の不確実性** | 既存辞書データのマイグレーション方法（エージェント未選択時の扱い） |
| **撤回基準** | ユーザーが複数エージェント間で辞書を共有したいケースが頻発した場合 |

## 根拠

エージェント単位での辞書管理は、ドメイン駆動設計の観点から正しい集約境界を定義している。定例MTGは独立したコンテキストを持ち、参加者・用語・文脈が異なる。辞書をエージェントに紐付けることで、各MTGのコンテキストを分離し、アジェンダ生成の精度を向上させる。

### 検討した選択肢

1. **選択肢A: 現状維持（user_id紐付け）**
   - 概要: 全辞書エントリを全エージェントで共有
   - メリット:
     - 実装変更不要
     - 辞書エントリの重複登録なし
   - デメリット:
     - コンテキスト汚染によるLLM精度低下
     - MTG固有の用語管理が困難
     - スケーラビリティの問題（エントリ数増加時）
   - 工数: 0日

2. **選択肢B: タグベース管理**
   - 概要: 辞書エントリにタグを付与し、エージェントごとにタグフィルタリング
   - メリット:
     - エントリの共有と分離を柔軟に制御可能
     - 既存データの互換性維持
   - デメリット:
     - タグ管理のUI/UX複雑化
     - クエリパフォーマンスの懸念（タグフィルタリング）
     - ドメインモデルの複雑化
   - 工数: 5日

3. **選択肢C: agent_id紐付け（採用）**
   - 概要: 辞書エントリをagent_idで直接紐付け
   - メリット:
     - シンプルなデータモデル
     - RLSポリシーで自然に保護可能
     - アジェンダ生成時のクエリが効率的
     - ドメインモデルと整合
   - デメリット:
     - 既存データのマイグレーション必要
     - 同じ辞書エントリを複数エージェントで使う場合は重複登録
   - 工数: 3日

## 比較

| 評価軸 | 選択肢A | 選択肢B | 選択肢C |
|--------|---------|---------|---------|
| 実装工数 | 0日 | 5日 | 3日 |
| LLM精度 | 低 | 中 | 高 |
| UI/UX | - | 複雑 | シンプル |
| 保守性 | 中 | 低 | 高 |
| RLS親和性 | 高 | 中 | 高 |
| ドメイン整合 | 低 | 中 | 高 |

## 影響

### ポジティブな影響

- アジェンダ生成時のLLM入力が最適化され、精度向上
- エージェント詳細画面で辞書を一元管理できるUX改善
- RLSポリシーがシンプルに（agent_id + user_id）
- 将来の辞書機能拡張（category, aliases）に対応しやすい

### ネガティブな影響

- 既存辞書データのマイグレーションが必要（エージェント割り当て）
- 複数エージェントで同じ用語を使う場合は重複登録が必要
- API/フロントエンドの変更範囲が広い

### 中立的な影響

- 独立した辞書ページは不要となり、エージェント詳細に統合

## データモデル変更

### 追加カラム

```sql
ALTER TABLE dictionary_entries
  ADD COLUMN agent_id UUID REFERENCES agents(id) ON DELETE CASCADE,
  ADD COLUMN category VARCHAR(50),
  ADD COLUMN aliases TEXT[];

-- RLSポリシーの更新（agent_id経由でuser_idを検証）
```

### カテゴリ定義

- `person`: 人名
- `project`: プロジェクト名
- `term`: 用語
- `customer`: 顧客名
- `abbreviation`: 略語

## 実装指針

### バックエンド

- クリーンアーキテクチャ（ADR-0001）に従い、ドメインエンティティを更新
- APIエンドポイントを`/api/v1/agents/{agent_id}/dictionary`に変更
- 正規化サービスはagent_idで辞書を取得

### フロントエンド

- `AgentDetailPage`に辞書セクションを追加
- 既存の`DictionaryPage`は段階的に廃止
- カスタムフック（React 19 best practice）でロジック分離

### マイグレーション

- 既存user_id紐付けのデータは、ユーザーがエージェント作成時に手動割り当て
- null agent_idのエントリは既存動作を維持（移行期間のみ）

## 関連情報

- ADR-0001: クリーンアーキテクチャ + DDD 採用
- PRD: ユビキタス言語辞書のデータ構造定義
- project-contextスキル: カテゴリ定義（人名/プロジェクト/用語/顧客/略語）

## References

- [React 19 Best Practices](https://dev.to/jay_sarvaiya_reactjs/react-19-best-practices-write-clean-modern-and-efficient-react-code-1beb) - カスタムフックパターンとコンポーネント設計
- [React Design Patterns](https://www.telerik.com/blogs/react-design-patterns-best-practices) - 2025年のReactデザインパターン
- [Vercel React Best Practices](https://vercel.com/blog/introducing-react-best-practices) - パフォーマンス最適化
